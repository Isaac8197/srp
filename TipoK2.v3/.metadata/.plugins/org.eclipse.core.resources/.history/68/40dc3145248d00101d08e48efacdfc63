/*
 * max6675.c
 *  Created on: Apr 9, 2023
 *      Author: Alcides Ramos
 */

#include "max6675.h"

void MAX6675_init(void)
{
    /* Reloj en 0, CS en inactivo (alto) */
    HAL_GPIO_WritePin(CK_MAX_GPIO_Port, CK_MAX_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(CS_MAX_GPIO_Port, CS_MAX_Pin, GPIO_PIN_SET);
#ifdef CS2_MAX_Pin
    HAL_GPIO_WritePin(CS2_MAX_GPIO_Port, CS2_MAX_Pin, GPIO_PIN_SET);
#endif
    HAL_Delay(100);
}

uint8_t MAX6675_pulso(void)
{
    uint8_t lei;
    HAL_GPIO_WritePin(CK_MAX_GPIO_Port, CK_MAX_Pin, GPIO_PIN_SET);
    Delay_us(10);
    lei = HAL_GPIO_ReadPin(DAT_MAX_GPIO_Port, DAT_MAX_Pin);
    HAL_GPIO_WritePin(CK_MAX_GPIO_Port, CK_MAX_Pin, GPIO_PIN_RESET);
    Delay_us(10);
    return lei;
}

/* NUEVO: lectura indicando el CS (sirve para cualquier cantidad de sensores en el bus) */
float MAX6675_lee_cs(GPIO_TypeDef *cs_port, uint16_t cs_pin)
{
    uint16_t max6675_dato = 0;
    int8_t   cont;

    /* habilita SOLO este dispositivo */
    HAL_GPIO_WritePin(cs_port, cs_pin, GPIO_PIN_RESET);

    for (cont = 15; cont >= 0; cont--) {
        if (MAX6675_pulso() == 1) {
            max6675_dato |= (uint16_t)(1u << cont);
        }
    }

    /* deshabilita el dispositivo */
    HAL_GPIO_WritePin(cs_port, cs_pin, GPIO_PIN_SET);

    /* descarta D2..D0 y escala 0.25 °C/LSB */
    return (float)((max6675_dato >> 3) * 0.25f);
}

/* Compatibilidad: igual que antes, lee el “sensor 1” (CS_MAX) */
float MAX6675_lee(void)
{
    return MAX6675_lee_cs(CS_MAX_GPIO_Port, CS_MAX_Pin);
}

