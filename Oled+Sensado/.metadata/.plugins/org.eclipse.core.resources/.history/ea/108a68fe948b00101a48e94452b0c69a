/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Rotary menu + OLED (SSD1306) + encoder TIM2 + PA2 switch
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "gpio.h"
#include "stdio.h"
#include "string.h"
#include <stdbool.h>

#include "ssd1306_oled.h"
#include "fonts.h"

/* Private typedef -----------------------------------------------------------*/

typedef enum {
  ST_MAIN = 0,
  ST_SUBMENU,
  ST_EDIT
} UiState;

/* Private define ------------------------------------------------------------*/
#define OLED_W         SSD1306_WIDTH
#define OLED_H         SSD1306_HEIGHT
#define LINE_H         12                 // altura de renglón usando Font_7x10
#define MARGIN_X       6
#define TITLE_Y        2
#define LIST_Y0        18
#define STAR_X         (OLED_W - Font_7x10.FontWidth)  // casi al borde derecho
#define SW_PORT        GPIOA
#define SW_PIN         GPIO_PIN_2         // pulsador del encoder (pull-up)

/* Private macros ------------------------------------------------------------*/
#define CLAMP(v,lo,hi)  ((v)<(lo)?(lo):((v)>(hi)?(hi):(v)))

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
TIM_HandleTypeDef htim2;

/* --- UI data --- */
static const char* kMainItems[3]   = {"Menu 1", "Menu 2", "Menu 3"};
static const char* kSubItems[4]    = {"Submenu 1", "Submenu 2", "Submenu 3", "Volver"};
// 3 menús x 3 submenús: presión (PSI) por defecto en 1
static int presionPSI[3][3] = {
  {1,1,1},
  {1,1,1},
  {1,1,1}
};

static UiState state = ST_MAIN;
static int mainIdx = 0;       // 0..2
static int subIdx  = 0;       // 0..3 (3 == Volver)
static int curMenu = 0;       // 0..2 seleccionado en ST_MAIN
static int curSub  = 0;       // 0..2 seleccionado en ST_SUBMENU (para editar)

/* Encoder tracking */
static int16_t lastEncPos = 0;

/* Switch debouncing */
static uint8_t swStable = 1;        // 1 = released (por pull-up)
static uint32_t swLastChange = 0;
static const uint32_t SW_DEBOUNCE_MS = 20;
static uint32_t lastPressTime = 0;  // anti-autorepeat

/* Buffers */
static char line[32];

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_I2C1_Init(void);
static void MX_TIM2_Init(void);

/* Helpers -------------------------------------------------------------------*/
static inline int16_t enc_get_pos(void) {
  // TIM2 en modo encoder (4 pulsos por "clic" del encoder)
  uint32_t counter = __HAL_TIM_GET_COUNTER(&htim2);
  return (int16_t)counter / 4;
}

static int enc_delta(void) {
  int16_t now = enc_get_pos();
  int d = (int)(now - lastEncPos);
  lastEncPos = now;
  return d;
}

static bool sw_pressed_edge(void) {
  // lectura cruda (activo en 0)
  uint8_t raw = (HAL_GPIO_ReadPin(SW_PORT, SW_PIN) == GPIO_PIN_SET) ? 1 : 0;

  if (raw != swStable) {
    if (HAL_GetTick() - swLastChange >= SW_DEBOUNCE_MS) {
      swStable = raw;
      swLastChange = HAL_GetTick();
      // flanco de bajada => pressed
      if (swStable == 0) {
        // anti-repetición simple
        if (HAL_GetTick() - lastPressTime > 150) {
          lastPressTime = HAL_GetTick();
          return true;
        }
      }
    }
  }
  return false;
}

/* Draw helpers --------------------------------------------------------------*/
static void draw_title(const char* txt) {
  SSD1306_GotoXY(MARGIN_X, TITLE_Y);
  SSD1306_Puts((char*)txt, &Font_11x18, WHITE);
}

static void draw_item(int row, const char* txt, bool selected) {
  uint16_t y = LIST_Y0 + row*LINE_H;
  SSD1306_GotoXY(MARGIN_X, y);
  if (selected) {
    SSD1306_Puts(">", &Font_7x10, WHITE);
    SSD1306_GotoXY(MARGIN_X + Font_7x10.FontWidth + 2, y);
  }
  SSD1306_Puts((char*)txt, &Font_7x10, WHITE);
}

static void screen_main(void) {
  SSD1306_Clear();
  draw_title("Bienvenido");
  for (int i=0;i<3;i++) {
    draw_item(i, kMainItems[i], i==mainIdx);
  }
  SSD1306_UpdateScreen();
}

static void screen_submenu(void) {
  SSD1306_Clear();
  snprintf(line, sizeof(line), "Menu %d", curMenu+1);
  draw_title(line);
  for (int i=0;i<4;i++) {
    draw_item(i, kSubItems[i], i==subIdx);
  }
  SSD1306_UpdateScreen();
}

static void screen_edit(void) {
  SSD1306_Clear();
  snprintf(line, sizeof(line), "Menu %d / Sub %d", curMenu+1, curSub+1);
  draw_title(line);

  uint16_t y = LIST_Y0; // primera línea de contenido
  // Presión actual
  snprintf(line, sizeof(line), "Presion: %d PSI", presionPSI[curMenu][curSub]);
  SSD1306_GotoXY(MARGIN_X, y);
  SSD1306_Puts(line, &Font_7x10, WHITE);

  // Asterisco a la derecha indicando edición activa
  SSD1306_GotoXY(STAR_X, y);
  SSD1306_Puts("*", &Font_7x10, WHITE);

  // Pista de uso
  SSD1306_GotoXY(MARGIN_X, y + LINE_H + 2);
  SSD1306_Puts("Girar=valor  Press=Guardar", &Font_7x10, WHITE);

  SSD1306_UpdateScreen();
}

/* USER CODE BEGIN 0 */
/* USER CODE END 0 */

int main(void)
{
  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
  SystemClock_Config();

  MX_GPIO_Init();
  MX_I2C1_Init();
  SSD1306_Init();
  MX_TIM2_Init();

  /* Start encoder */
  HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);
  lastEncPos = enc_get_pos();

  /* First screen */
  screen_main();

  while (1)
  {
    int d = enc_delta();         // >0: abajo, <0: arriba (o viceversa según conexión)
    bool press = sw_pressed_edge();

    switch (state) {

      case ST_MAIN: {
        if (d != 0) {
          mainIdx = CLAMP(mainIdx + (d>0 ? 1 : -1), 0, 2);
          screen_main();
        }
        if (press) {
          curMenu = mainIdx;
          subIdx  = 0;
          screen_submenu();
          state = ST_SUBMENU;
        }
      } break;

      case ST_SUBMENU: {
        if (d != 0) {
          subIdx = CLAMP(subIdx + (d>0 ? 1 : -1), 0, 3); // 3 = Volver
          screen_submenu();
        }
        if (press) {
          if (subIdx == 3) {
            // Volver al menú principal
            screen_main();
            state = ST_MAIN;
          } else {
            // Entrar a editar presión de Submenu 1..3
            curSub = subIdx;
            screen_edit();
            state = ST_EDIT;
          }
        }
      } break;

      case ST_EDIT: {
        if (d != 0) {
          // cambiar presión (>=0)
          int v = presionPSI[curMenu][curSub];
          v += (d>0 ? 1 : -1);
          if (v < 0) v = 0;
          presionPSI[curMenu][curSub] = v;
          screen_edit();
        }
        if (press) {
          // guardar y volver al submenú
          screen_submenu();
          state = ST_SUBMENU;
        }
      } break;
    }

    HAL_Delay(40);  // ritmo de refresco + anti-rebote suave
  }
}

/* ======= ST's generated code below (sin cambios relevantes) =============== */

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }
}

void MX_I2C1_Init(void)
{
  hi2c1.Instance             = I2C1;
  hi2c1.Init.ClockSpeed      = 400000;
  hi2c1.Init.DutyCycle       = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1     = 0;
  hi2c1.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2     = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) { Error_Handler(); }
}

static void MX_TIM2_Init(void)
{
  TIM_Encoder_InitTypeDef sConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim2.Instance = TIM2;
  htim2.Init.Prescaler         = 0;
  htim2.Init.CounterMode       = TIM_COUNTERMODE_UP;
  htim2.Init.Period            = 65535;
  htim2.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode    = TIM_ENCODERMODE_TI12;
  sConfig.IC1Polarity    = TIM_ICPOLARITY_FALLING;
  sConfig.IC1Selection   = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler   = TIM_ICPSC_DIV1;
  sConfig.IC1Filter      = 0;
  sConfig.IC2Polarity    = TIM_ICPOLARITY_FALLING;
  sConfig.IC2Selection   = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler   = TIM_ICPSC_DIV1;
  sConfig.IC2Filter      = 0;
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK) { Error_Handler(); }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode     = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) { Error_Handler(); }
}

void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  // Switch del encoder (PA2) pull-up
  GPIO_InitStruct.Pin  = GPIO_PIN_2;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  // (Si tenés otras IRQs/entradas, podés dejarlas como ya estaban)
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) { }
}


#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
